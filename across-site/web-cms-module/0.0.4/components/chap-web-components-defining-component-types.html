<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled :: Across</title>
    <meta name="generator" content="Antora 1.0.0">
    <link rel="stylesheet" href="../../../_/css/site.css">
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../..">Across</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="main-wrapper">
<div class="navigation-container" data-component="web-cms-module" data-version="0.0.4">
  <aside class="navigation" role="navigation">
    <div class="panels">
<div class="navigation-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Module: Web CMS</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <span class="nav-text">Creating a form</span>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="navigation-explore" data-panel="explore">
  <div class="context">
    <span class="title">Module: Web CMS</span>
    <span class="version">0.0.4</span>
  </div>
  <ul class="components">
    <li class="component">
      <span class="title">Across</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../across/3.0.0/index.html">3.0.0</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Application Guides</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../guides/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Migration guides</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../migration/dev/index.html">dev</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Admin Web</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../admin-web-module/3.0.1/index.html">3.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Bootstrap UI</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../bootstrap-ui-module/2.0.1/index.html">2.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Documents & Forms</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../dynamic-forms-module/0.0.1/index.html">0.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Entity Management</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../entity-module/3.0.1/index.html">3.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: LDAP Support</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../ldap-module/1.0.1/index.html">1.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Module: Security - ACLs</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../spring-security-acl-module/3.0.1/index.html">3.0.1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <span class="title">Module: Web CMS</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">0.0.4</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
  <main class="main" role="main">
<div class="toolbar" role="navigation">
  <button class="navigation-toggle"></button>
  <a href="../../../across/3.0.0/index.html" class="home-link"></a>
<nav class="crumbs" role="navigation" aria-label="breadcrumbs">
</nav>
  <div class="edit-this-page"><a href="https://github.com/ForeachOS/ax-docs-web-cms-module/edit/develop/docs/modules/ROOT/pages/components/chap-web-components-defining-component-types.adoc">Edit this Page</a></div>
</div>
<article class="doc">
<div class="sect1">
<h2 id="components-defining-component-types"><a class="anchor" href="#components-defining-component-types"></a>Defining component types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can easily define your own component types.
Depending on your needs you can <a href="#components-extending-base-types">extend one of the base types</a> or create a <a href="#components-custom-component-type">fully custom implementation</a>.</p>
</div>
<div class="sect2">
<h3 id="components-extending-base-types"><a class="anchor" href="#components-extending-base-types"></a>Extending the base types</h3>
<div class="paragraph">
<p>You can add a custom <code>WebCmsComponentType</code> by importing it via YAML or by adding it via the <code>WebCmsComponentTypeRepository</code>.
Component types to import should be defined in the section <strong>types - component</strong> where the key of a component type definition is the`unique <code>WebCmsComponentType</code> <code>typeKey</code>.</p>
</div>
<div class="listingblock">
<div class="title">Example YAML component type definition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">types:
  component:
    my-component:
      name: Custom component
      description: Custom HTML component with additional metadata.
      attributes:
        type: markup
        metadata: "my.component.MyMetadata"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>WebCmsComponentType</code> has a collection of attributes.
This is a map of <code>String</code> key/value pairs.
Adding attributes is a way to provide processing metadata without having to create custom <code>WebCmsComponentType</code> implementations.</p>
</div>
<div class="paragraph">
<div class="title">Default attributes</div>
<p>All base types support 3 default attributes that pack a lot of punch in creating custom component types:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>type</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contains the base type for the component type.</p>
<p class="tableblock"> Examples: <em>container</em>, <em>markup</em> &#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>template</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional: identifier of the (Thymeleaf) template that should be used for rendering the resulting <code>WebCmsComponentModel</code> for a component of this type.</p>
<p class="tableblock">Example: <em>th/mymodule/mytemplate :: fragment</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>metadata</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional: name of the class that should be used for the component metadata.</p>
<p class="tableblock">Example: <em>my.module.components.MyComponentMetadata</em></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<div class="title">Custom template</div>
<p>Any component type can have a <em>template</em> attribute set that identifies the (Thymeleaf) template that should be used for rendering the component instances.
If a template is specified it will always be used for rendering and any other <code>WebCmsComponentModelRenderer</code> for that component type will be skipped.</p>
</div>
<div class="paragraph">
<p>You can customize rendering the default <code>WebCmsComponentModel</code> implementations just by specifying a custom template.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Property <code>renderTemplate</code> on <code>WebCmsComponentModel</code> allows you to set a custom template per-component instead of per component type.
If a <code>renderTemplate</code> is set on the component itself, it will take precedence over the <code>WebCmsComponentType</code> template attribute.
Setting <code>renderTemplate</code> is not enabled by default in the administration UI.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<div class="title">Metadata</div>
<p>Any <code>WebCmsComponentModel</code> has a <code>metadata</code> property that refers to an object that has all custom metadata for a component.
The type of metadata object is configured by setting the class name as the <em>metadata</em> attribute on the <code>WebCmsComponentType</code>.
The metadata instance will always be created as a prototype using the <code>BeanFactory</code> and as such supports autowiring other beans from the <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>A metadata class must:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>be serializable to and from JSON using Jackson <code>ObjectMapper</code></p>
<div class="ulist">
<ul>
<li>
<p>Jackson annotations on the metadata class are supported if necessary to define (de-)serializer rules</p>
</li>
<li>
<p>special care should be taken not to serializer any beans that might have been wired</p>
</li>
</ul>
</div>
</li>
<li>
<p>implement a valid <code>equals()</code> method in order to have change detection and better import/export performance</p>
</li>
<li>
<p>be easily cloneable:</p>
<div class="ulist">
<ul>
<li>
<p>have either a no-arguments public constructor and provide setters/getters for all relevant properties</p>
</li>
<li>
<p>OR implement <code>EntityWithDto</code> or <code>Cloneable</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the administration UI is active, a form for metadata properties will automatically be generated using the EntityModule.
This does require you to register the metadata type as an entity in the <code>EntityRegistry</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Default (de-)serialization for <code>WebCmsObject</code> implementations is provided by the {module-name} by dispatching to the <code>WebCmsDataConversionService</code>.
This means metadata properties can often refer to other web cms types without requiring custom configuration.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="#components-custom-component-type">creating a custom component type</a> if you want to have a custom metadata class, change serialization or admin UI rendering.</p>
</div>
<div class="paragraph">
<div class="title">Providing a component template</div>
<p>When defining a custom component type, you can link a <strong>componentTemplate</strong> component to the <code>WebCmsComponentType</code> definition.
If present, that component will be used as a template for a new component of your custom component type.
Class properties as well as any child components will be copied to a new component your type.</p>
</div>
<div class="paragraph">
<p>When your component type and <strong>componentTemplate</strong> are a container type, any <code>TextWebCmsComponentModel</code> member of the template component can have special markers in its content.
These markers will be replaced when copying the template to a newly created component:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@@container.name@@</code> will be replaced with the <code>name</code> of the newly created container</p>
</li>
<li>
<p><code>@@container.title@@</code> will be replaced with the <code>title</code> of the newly created container</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <strong>componentTemplate</strong> should have the same class implementation as the component type being defined.
For example when creating a <strong>fixed-container</strong>, the <strong>componentTemplate</strong> must implement <code>ContainerWebCmsComponentModel</code>.
Providing custom metadata is not supported on the template component, the metadata will be reset when creating a new component.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_example_custom_container_component"><a class="anchor" href="#_example_custom_container_component"></a>Example: custom container component</h4>
<div class="paragraph">
<p>This is an example of a custom component that is a fixed container with 2 member components.
A custom metadata class allows configuring the position of the members (left or right), the custom template uses the metadata to determine what the output should be.</p>
</div>
<div class="listingblock">
<div class="title">Component definition</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">types:
  component:
    left-right:
      name: Left or Right
      description: Renders 2 components in a specific layout.
      attributes:
        type: fixed-container
        template: "th/mymodule/components :: left-right"
        metadata: "mymodule.LeftRightMetadata"
      wcm:components:
        componentTemplate:
          componentType: container
          wcm:components:
            one:
              componentType: rich-text
              title: One
              sortIndex: 1
              body: "@@container.name@@"
            two:
              componentType: rich-text
              title: Two
              sortIndex: 2
              body: "@@container.title@@"</code></pre>
</div>
</div>
<div class="paragraph">
<p>When creating a new <em>left-right</em> component the members of <em>componentTemplate</em> will be cloned into the new container.
The text components <em>one</em> and <em>two</em> will get their default content set with respectively the name and title of the new <em>left-right</em> component.</p>
</div>
<div class="paragraph">
<p>The <em>sortIndex</em> will determine the order of the components in the administration UI.</p>
</div>
<div class="listingblock">
<div class="title">Metadata class</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Data   // Use Lombok @Data to generate getters, setters and equals() method
public class LeftRightMetadata
{
    enum Layout
    {
        LEFT_TO_RIGHT,
        RIGHT_TO_LEFT
    }

    /**
     * Determines the order of rendering one and two.
     */
    @NotNull
    private Layout layout = Layout.LEFT_TO_RIGHT;
}

// Register the metadata class as an entity as to activate the administration UI
@Configuration
@ConditionalOnAdminUi
class LeftRightConfiguration implements EntityConfigurer {
    @Override
    public void configure( EntitiesConfigurationBuilder entities ) {
        entities.create().entityType( LeftRightMetadata.class, true );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The metadata only has a single property <code>layout</code>.
When the administration UI is active (presence of EntityModule and AdminWebModule) the layout value can be selected in the user interface.
The default administration UI uses the the EntityModule to build the metadata form, so we register the <code>LeftRightMetadata</code> as an entity.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not want to use the EntityModule to generate the metadata form, you can provide a custom <code>WebCmsComponentModelMetadataAdminRenderer</code>.
See <a href="#components-custom-component-type">create a custom component type</a> for more information.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title">Thymeleaf template: th/mymodule/components</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;th:block th:fragment="left-right(component)"
          th:with="metadata=${component.metadata}"&gt;
    &lt;section th:if="${metadata.layout.name() eq 'LEFT_TO_RIGHT'}"&gt;
        &lt;div class="left"&gt;&lt;across:view element="${component.getMember('one')}" /&gt;&lt;/div&gt;
        &lt;div class="right"&gt;&lt;across:view element="${component.getMember('two')}" /&gt;&lt;/div&gt;
    &lt;/section&gt;
    &lt;section th:if="${metadata.layout.name() eq 'RIGHT_TO_LEFT'}"&gt;
        &lt;div class="left"&gt;&lt;across:view element="${component.getMember('two')}" /&gt;&lt;/div&gt;
        &lt;div class="right"&gt;&lt;across:view element="${component.getMember('one')}" /&gt;&lt;/div&gt;
    &lt;/section&gt;
&lt;/th:block&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Thymeleaf template inspects the metadata <code>layout</code> property and renders members <em>one</em> and <em>two</em> in a fixed location.
As a <code>WebCmsComponentModel</code> is a <code>ViewElement</code> using an <em>across:view</em> node takes care of rendering the member components.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_filtering_selectable_webcmscomponenttype_options"><a class="anchor" href="#_filtering_selectable_webcmscomponenttype_options"></a>Filtering selectable WebCmsComponentType options</h3>
<div class="paragraph">
<p>To filter the provided dropdown options for a WebCmsComponent, the user can perform two actions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>options that should never be present by default</p>
</li>
<li>
<p>selected set of options that should be present.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These actions are provided through the <code>DefaultAllowedComponentTypeFetcher</code>. Should you like to provide your own logic to filter the selectable options, for one or more types, you will have to provide your own implementations of the <code>WebCmsAllowedComponentTypeFetcher</code> interface.</p>
</div>
<div class="sect3">
<h4 id="_non_selectable_webcmscomponenttypes"><a class="anchor" href="#_non_selectable_webcmscomponenttypes"></a>Non-selectable WebCmsComponentTypes</h4>
<div class="paragraph">
<p>To prevent a <code>WebCmsComponentType</code> from showing up in the list unless explicitly specified, the user has to provide the component type with the <code>componentRestricted</code> attribute, with its value set to true. This ensures that unless the WebCmsComponentType is specified as an option for the <code>WebCmsObject</code> through a <code>WebCmsTypeSpecifierLink</code>, it will never be shown as an option.</p>
</div>
<div class="paragraph">
<p>Examples of non-selectable WebCmsComponentTypes are the default placeholder, proxy and fixed-container component types.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">types:
  component:
    fixed-container:
      objectId: "wcm:type:component:fixed-container"
      name: Fixed container
      description: Container of a fixed set of components.
      attributes:
        type: fixed-container
        componentRestricted: true</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>fixed-container</em> should never be available as a selectable option unless specified (through a <code>WebCmsTypeSpecifierLink</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_selectable_webcmscomponenttype_options"><a class="anchor" href="#_selectable_webcmscomponenttype_options"></a>Selectable WebCmsComponentType options</h4>
<div class="paragraph">
<p>In the case where a component type may only contain other specific component types, the type should be provided by the <code>childComponentsRestricted</code> attribute, with its value set to true. The provided component type options will then be equal to the specified <code>WebCmsTypeSpecifierLink</code> links with link type <em>allowed-component</em>.</p>
</div>
<div class="paragraph">
<p>Example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">types:
  component:
    partner-container:
      name: Partners
      attributes:
        type: container
        childComponentsRestricted: true
      wcm:types:
        - typeSpecifier: "wcm:type:component:partner"
          linkType: allowed-component</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A <em>partner-container</em> should only contain components of the type <em>partner</em></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="components-custom-component-type"><a class="anchor" href="#components-custom-component-type"></a>Custom component type</h3>
<div class="paragraph">
<p>Apart from extending one of the base types and using a custom template or metadata class, you can also pretty much customize any part of the component related infrastructure by providing specific interface implementations.
This allows you to create a fully custom component type and read/write/render or manage it in whichever way you like.</p>
</div>
<div class="paragraph">
<p>The following list of the component related interfaces and their role:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Interface</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebCmsComponentModelReader</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts from a <code>WebCmsComponent</code> to the relevant <code>WebCmsComponentModel</code> implementation.
If you want to have the default metadata support, consider extending <code>AbstractWebCmsComponentModelReader</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebCmsComponentModelWriter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Saves a <code>WebCmsComponentModel</code> to the backing repository.
Provides the backing <code>WebCmsComponent</code>.
Consider extending <code>AbstractWebCmsComponentModelWriter</code> if you want default metadata support.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebCmsComponentModelRenderer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Renders a <code>WebCmsComponentModel</code> in a Thymeleaf template.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebCmsComponentModelContentAdminRenderer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides a <code>ViewElementBuilder</code> for managing the content of a <code>WebCmsComponentModel</code> in the administration UI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebCmsComponentModelMetadataAdminRenderer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides a <code>ViewElementBuilder</code> for managing the metadata of a <code>WebCmsComponentModel</code> in the administration UI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebCmsComponentModelMembersAdminRenderer</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides a <code>ViewElementBuilder</code> for managing child components (usually container members) of a <code>WebCmsComponentModel</code> in the administration UI.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebCmsComponentAutoCreateStrategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Builds a <code>WebCmsComponentModel</code> when it is being auto-created, for example during first render of a template.
Gets the processed template markup as input parameters.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>All component related interfaces use the same processing approach:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>all beans of that type are detected and ordered</p>
</li>
<li>
<p>a <code>supports()</code> method is used to check if the bean applies for a certain component</p>
</li>
<li>
<p>the first bean that applies will be used</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As the implementations are always queried in order, customizing an implementation is a matter of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>providing your implementation as a bean</p>
</li>
<li>
<p>implementing <code>supports()</code> to match for all component types you want</p>
</li>
<li>
<p>ensure your bean is ordered (use <code>@Order</code> or implement <code>Ordered</code>) before any other that might also apply for that component type</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_customizing_the_components_administration_ui"><a class="anchor" href="#_customizing_the_components_administration_ui"></a>Customizing the components administration UI</h3>
<div class="paragraph">
<p>WebCmsModule provides a default administration UI built on AdminWebModule and EntityModule.</p>
</div>
<div class="paragraph">
<p>The default administration UI uses a form of tabs to display the different sections (eg. content, members, metadata) of a component.  Only sections relevant for the component type will be shown to the user.</p>
</div>
<div class="sect3">
<h4 id="_administration_ui_labels_and_descriptions"><a class="anchor" href="#_administration_ui_labels_and_descriptions"></a>Administration UI labels and descriptions</h4>
<div class="paragraph">
<p>The default administration UI for components supports configuring the labels.  See the <a href="#">{doc-appendix}.adoc#appendix-message-codes</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_custom_component_forms"><a class="anchor" href="#_creating_custom_component_forms"></a>Creating custom component forms</h4>
<div class="paragraph">
<p>You can customize the forms being rendered by providing custom <code>xAdminRenderer</code> implementations.  This allows you to build</p>
</div>
</div>
<div class="sect3">
<h4 id="components-component-profiles"><a class="anchor" href="#components-component-profiles"></a>Configuring rich-text and markup components</h4>
<div class="paragraph">
<p>WebCmsModule supports rich text components and HTML components out of the box, using TinyMCE and CodeMirror respectively.  Rich-text components are identified with the base type <code>rich-text</code>, markup with <code>markup</code>.</p>
</div>
<div class="listingblock">
<div class="title">YAML definition of default Rich text and HTML component types</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">rich-text:
  objectId: "wcm:type:component:rich-text"
  name: Rich text
  description: Rich text component - supporting HTML markup and default assets if enabled by other modules.
  attributes:
    type: rich-text
    profile: rich-text
html:
  objectId: "wcm:type:component:html"
  name: HTML
  description: A snippet of HTML.
  attributes:
    type: markup</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to the base type, a component type can define a <strong>profile</strong> attribute value, denoting a custom profile that should be used to initialize the editor for that component type.
The default rich-text component type uses a profile called <code>rich-text</code> as well.</p>
</div>
<div class="paragraph">
<p>You can customize the profile configuration using Javascript.  This is done by registering profiles on the <code>WebCmsComponentProfileRegistry</code>.  A profile registration requires the following three attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>componentType</strong>: this is the base type of the component (eg. <code>rich-text</code> or <code>markup</code>)</p>
</li>
<li>
<p><strong>profileName</strong>: a unique profile name</p>
</li>
<li>
<p><strong>profile</strong>: JSON object that holds the actual profile data (for example the TinyMCE configuration object)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Profiles can be inherited.  If your profile data has a <strong>_parentProfile</strong> attribute, the value is expected to be the name of another profile for the same component type.  The final profile will be the data of the parent profile merged together with the requested profile.  Values from the parent will be replaced by values from the requested profile. Every profile can have a (optional) single parent.</p>
</div>
<div class="listingblock">
<div class="title">Example registration of custom rich-text type</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">(function ( $ ) {
  /**
   * Limited rich-text profile: inherit from the _base profile
   * and only show bold/italic buttons.
   */
  WebCmsComponentProfileRegistry.registerProfileForComponentType(
    'rich-text', /* component type */
    'limited', /* profile name */
    {
      _parentProfile: '_base',
      toolbar1: 'bold italic'
    }
  );
})(jQuery);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Custom profiles must be registered in Javascript.  This usually happens before initialization of form elements (as the profiles should already be registered when that happens), but it must happen after the inclusion of the <code>TextWebCmsComponentAdminResources</code> package and in the javascript page end phase. The reason for this is that the profile registry and the default profiles are defined during <code>JAVASCRIPT_PAGE_END</code> of the WebCmsModule resources.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_default_profiles"><a class="anchor" href="#_default_profiles"></a>Default profiles</h5>
<div class="paragraph">
<p>The following default profiles are available:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Component type</th>
<th class="tableblock halign-left valign-top">Profile name</th>
<th class="tableblock halign-left valign-top">Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rich-text</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_base</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base profile for technical configuration of TinyMCE.  Sets up things like the image picket configuration, toolbar behaviour etc.  It&#8217;s probably best to have your custom profiles inherit from this one.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rich-text</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>default</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default profile for a TinyMCE editor: configures default plugins and toolbars.  Extends <code>_base</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rich-text</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rich-text</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Actual profile used by the default Rich text component.  Inherits from <code>default</code> but adds no custom settings - as such is identical to <code>default</code> out of the box.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>markup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>default</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default CodeMirror configuration used by the HTML component.  Inherits from a <code>_base</code> profile even though no <code>_base</code> is defined.  You can either replace <code>default</code> with your custom settings or register the <code>_base</code> profile to extend <code>default</code> indirectly.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_detecting_tab_switching"><a class="anchor" href="#_detecting_tab_switching"></a>Detecting tab switching</h4>
<div class="paragraph">
<p>Sometimes tab switching needs to be detected in order to re-render the client-side interface.
Any element that has data attribute <strong>data-wcm-component-refresh</strong> set will receive the <em>wcm:componentRefresh</em> event whenever a component tab is being activated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">// Example refreshing the RTE when a component tab is being switched
$( '[data-wcm-markup-type=markup]', node ).each( function () {
    var cm = CodeMirror.fromTextArea( $( this )[0], {} );
    $( this ).on( 'wcm:componentRefresh',
                  function () {
                      cm.refresh();
                  } )
            .attr( 'data-wcm-component-refresh', 'true' );  // ensure we receive the event
} );</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</article>
  </main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script src="../../../_/js/vendor/highlight.js"></script>
<script>hljs.initHighlighting()</script>
  </body>
</html>
